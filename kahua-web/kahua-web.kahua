;;-*-Scheme-*-
;; Kahua website
;;
;;  Copyright (c) 2004 Scheme Arts, L.L.C., All rights reserved.
;;  Copyright (c) 2004 Time Intermedia Corporation, All rights reserved.
;;  See COPYING for terms and conditions of using this software
;;
;; $Id: kahua-web.kahua,v 1.22 2004/06/25 11:16:20 nobsun Exp $

(use srfi-1)
(use srfi-2)
(use srfi-13)
(use file.util)
(use util.list)
(use rfc.uri)
(use gauche.logger)
(use gauche.sequence)
(use gauche.parameter)
(use wiliki.format)
(use wiliki.log)

(primary-database-name
 (build-path (ref (kahua-config) 'working-directory) "kahua-web"))

(log-open (kahua-logpath "kahua-web.log"))
(load "kahua-web/macro.kahua")
(load "kahua-web/login.kahua")
(load "kahua-web/search.kahua")
(load "kahua-web/mailform.kahua")

;;========================================================
;; Application error handling
;;
;;   An error that causes a normal occasion (e.g. input error)
;;   can be thrown by <kahua-error> object.
;;   The <error> would be considered as a program error.
;;   NB: <kahua-error> should go to kahua module?

(define-class <kahua-error> (<exception>)
  ((form :init-keyword :form :init-value #f) ;; form to display.  [SXML]
   ))

(define (kahua-error form)
  (raise (make <kahua-error> :form form)))

;;========================================================
;; Page-data
;;

;; NB: there's no way to delete a <page-data>.  A 'deleted' pages
;; will be marked as "hidden".

(define-class <page-data> (<kahua-persistent-base>)
  ((name       :allocation :persistent :init-keyword :name)
   (content    :allocation :persistent :init-keyword :content
               :init-value "")
   (ctime      :allocation :persistent :init-keyword :ctime
               :init-value (sys-time))
   (cuser      :allocation :persistent :init-keyword :cuser
               :init-value #f)
   (mtime      :allocation :persistent :init-keyword :mtime
               :init-value #f)
   (muser      :allocation :persistent :init-keyword :muser
               :init-value #f)
   (hidden     :allocation :persistent :init-keyword :hidden
               :init-value #f)
   ))

;; [<page-data>]
(define (all-page-data)
  (filter (lambda (x) (not (ref x 'hidden)))
          (make-kahua-collection <page-data>)))

;; pagename -> Maybe <page-data>
;; pagename must be canonicalized.
(define (get-page-data pagename)
  (find (lambda (p) (equal? (ref p 'name) pagename)) (all-page-data)))

(define (page-data-exists? pagename)
  (not (not (get-page-data pagename)))) ;; for now

(define (get-page-data-from-id id)
  (find-kahua-instance <page-data> id))

(define-method pagename<? ((a <page-data>) (b <page-data>))
  (string<? (ref a 'name) (ref b 'name)))

;;========================================================
;; Page
;;

;; <page> class is used to represent any "displayable" pages, including
;; procedurally constructed page.
;; For the page that has persistent <page-data>, persistent-id slot
;; containts <page-data>'s id.
(define-class <page> (<wiliki-page>)
  ((persistent-id :init-keyword :persistent-id :init-value #f)
   (virtual-pages :allocation :class :init-value '())))

(define (persistent-page? page)
  (and (is-a? page <page>) (ref page 'persistent-id)))

(define (add-virtual-page! pagename proc)
  (class-slot-set! <page> 'virtual-pages
                   (assoc-set! (class-slot-ref <page> 'virtual-pages)
                               pagename proc)))

(define (lookup-virtual-page pagename)
  (assoc-ref (class-slot-ref <page> 'virtual-pages) pagename))

;; current page
;; NB: this is different from wiliki:current-page, which contains
;; the page being currently formatted.  This current-page keeps
;; the "toplevel" page to be shown.
(define current-page (make-parameter #f))

;; <page-data> -> <page>
(define (page-data->page data)
  (make <page>
    :title (base-pagename (ref data 'name))
    :key   (ref data 'name)  :persistent-id (key-of data)
    :content (ref data 'content)
    :ctime (ref data 'ctime) :cuser (ref data 'cuser)
    :mtime (ref data 'mtime) :muser (ref data 'muser)))

;; pagename -> Maybe <page>
;; pagename must be canonicalized.
(define (get-page pagename)
  (cond ((not pagename) #f) ;; for safety
        ((lookup-virtual-page pagename) => (cut <> pagename))
        ((get-page-data pagename) => page-data->page)
        (else #f)))

;; save page.
(define (save-page page cont)
  (define (get-page-data/check id)
    (let* ((data (get-page-data-from-id id))
           (newname (ref page 'key))
           (oldname (ref data 'name)))
      (unless (equal? oldname newname)
        ;; page name is changed.  make sure it doesn't conflict.
        (let1 other (get-page-data newname)
          (when (and other (not (equal? (ref data 'id) (ref other 'id))))
            (set! (ref page 'key) oldname)
            (kahua-error (duplicated-page-name newname))))
        (set! (ref data 'name) newname))
      data))
  (define (get-new-page/check name)
    (let1 other (get-page-data name)
      (when other (kahua-error (duplicated-page-name name)))
      (make <page-data> :name (ref page 'key))))
  (define (duplicated-page-name name)
    (edit-page page
               `(p (@ (class "warning"))
                   "A page with name \"" ,name "\" already exists. "
                   "Use a different name.")))

  (let ((data (cond ((ref page 'persistent-id) => get-page-data/check)
                    (else (get-new-page/check (ref page 'key))))))
    (set! (ref data 'content) (ref page 'content))
    (unless (ref page 'persistent-id)
      (set! (ref data 'cuser) (kahua-current-user-name)))
    (set! (ref data 'mtime) (sys-time))
    (set! (ref data 'muser) (kahua-current-user-name))
    (kahua-db-sync)
    (if (ref page 'persistent-id)
      (cont page)
      (cont (page-data->page (get-page-data (ref page 'key)))))
    ))

(define (front-page? page)
  (equal? (ref page 'key) "/"))

;; NB: front page is a virtual page.  contents is created by
;; "/$admin/home"
(add-virtual-page!
 "/"
 (lambda (name)
   (make <page>
     :title "Kahua home" :key "/" :content (use-page "/$admin/home"))))

;;========================================================
;; Page set
;;

(define-class <page-set> (<kahua-persistent-base>)
  ((name       :init-keyword :name :init-value #f
               :allocation :persistent)
   (max-pages  :init-keyword :max-pages :init-value #f
               :allocation :persistent)
   (pages      :init-keyword :pages :init-value '()
               :allocation :persistent)
   ))

(define-method key-of ((self <page-set>))
  (x->string (ref self 'name)))

;; assume pagename is canonicalized
(define-method page-set-push-unique! ((self <page-set>) (page <page>))
  (let1 lis (cons (ref page 'persistent-id)
                  (remove (cut equal? (ref page 'persistent-id) <>)
                          (ref self 'pages)))
    (set! (ref self 'pages)
          (cond ((ref self 'max-pages) => (cut take* lis <>))
                (else lis)))))

;; (String, Bool=#f, MaxPages=#f) -> <page-set>
;; second arg specifies whether it should create a new page set if
;; the named one doesn't exist.
(define (get-page-set page-set-name . opts)
  (let-optionals* opts ((create? #f) (maxpages #f))
    (or (find-kahua-instance <page-set> page-set-name)
        (and create?
             (make <page-set>
               :name page-set-name
               :max-pages maxpages)))))

;; Default page sets.  recent-changes and news
(define (page-set:recent-changes) (get-page-set "recent-changes" #t 50))
(define (page-set:news)           (get-page-set "news" #t 50))

;;========================================================
;; Page paths
;;

;; Kahua-web's pages can be constructed in hierarchy.
;; Each page has a name beginning with "/", and have similar
;; structure like pathnames.
;; Within the page, wikiname can refer to the other pages
;; by "relative pathname".
;;
;; Note that the page is not a "directory"---there's no real
;; container in the database, but only a conceptual group of
;; names.   An unqualified name refers to the page in the
;; same conceptual directory---that is, "baz" in the page
;; "/foo/bar" means "/foo/baz", not "/foo/bar/baz".
;;
;; The pathname component "." and ".." can be used to point relative
;; names.  Note that these also works from the conceptual directory
;; where the page is in, so "./baz" in the page "/foo/bar" is
;; "/foo/baz", and "../baz" in the page "/foo/bar" is "/baz".
;;
;; A special name "$" refers to the page itself.  So "$/baz" in the
;; page "/foo/bar" means "/foo/bar/baz".
;;
;; The name of the top page is "/".
;; The "parent" page of the top page is the top page itself.
;; That is, "/a/../.." refers to "/", and "/a/../../b" refers to "/b".

;; Get canonical (absolute) pathname of the page.
;; Returns #f if pagename is invalid.
(define (canon-pagename pagename . current)
  (define (fix-up path) ;; strips leading "/.."
    (cond ((string-null? path) "/")
          ((string-prefix? "/.." path) (fix-up (string-drop path 3)))
          ((string-suffix? "/" path) (string-drop-right path 1))
          (else path)))
  (define (canon-path path . more-paths)
    (fix-up (simplify-path (apply build-path path more-paths))))
  (if (absolute-path? pagename)
    (canon-path pagename)
    (and-let* ((curpage (get-optional current
                                      (cond ((current-page)
                                             => (cut ref <> 'key))
                                            (else #f)))))
      (cond ((equal? pagename "$") curpage)
            ((string-prefix? "$/" pagename)
             (canon-path curpage (string-drop pagename 2)))
            (else
             (canon-path (sys-dirname curpage) pagename))))))

;; Base name to be used for display
;;  NB: it is arguable that whether we should display the pathname
;;  component if the pointed page is in different "directory".
;;  For now, I just take the basename (except the "/").
(define (base-pagename pagename)
  (if (equal? pagename "/") "/" (sys-basename pagename)))

;; "/aa/bb/cc" -> '("aa" "bb" "cc")
;; "/" -> '()
(define (pagename-split pagename . opts)
  (let1 c (canon-pagename pagename)
    (and c (if (or (string-null? c) (string=? c "/"))
             '()
             (string-split (string-drop c 1) #\/)))))

;; '("aa" "bb" "cc") => "/aa/bb/cc"
;; '() => "/"
(define (pagename-join components)
  (string-append "/" (string-join components "/")))

;; Formatting wikiname.
(define (format-wikiname name)
  (receive (path linkname) (string-scan name "//" 'both)
    (let ((absname  (canon-pagename (or path name)))
          (linkname (or linkname (base-pagename name))))
      (if absname
        (if (or (lookup-virtual-page absname)
                (page-data-exists? absname))
          `((a/cont (@@ (cont ,show ,@(pagename-split absname)))
                    ,linkname))
          `(,linkname
            (a/cont (@@ (cont ,edit ,@(pagename-split absname)))
                    "?")))
        (list #`"[[,name]]")))))

;;========================================================
;; Page formatters
;;

;; +---------------------------------------------------+
;; |title-pane                                         |
;; +---------------------------------------------------+
;; |navigation-pane                  [login]  [search] |
;; +---------------------------------------------------+
;; |side-pane |Page Title                              |
;; |          |                                        |
;; |          |  contents...                           |
;; |          |                                        |
;; :          :                                        :
;; |          |                                        |
;; +---------------------------------------------------+
;; |                   bottom-pane                     |
;; +---------------------------------------------------+

(define (standard-page page)

  (define (fmt-time t)
    (sys-strftime "%Y/%m/%d %H:%M:%S" (sys-localtime t)))
  
  (define (footer page)
    `((div (@ (id "page-footer"))
           ,@(cond-list
              ((ref page 'ctime)
               => (lambda (t) (format "Created: ~a" (fmt-time t))))
              ((ref page 'cuser) => (cut format " by ~a" <>))
              (#t '(br))
              ((ref page 'mtime)
               => (lambda (t) (format "Modified: ~a" (fmt-time t))))
              ((ref page 'muser) => (cut format " by ~a" <>))))
      ,@(if (and-let* ((name (kahua-current-user-name)))
             (not (string-null? name)))
           `((div (@ (id "edit-menu"))
                  (a/cont (@@ (cont ,edit ,@(pagename-split (ref page 'key))))
                          "[Edit]")
                  "[History]"))
           '())))

  (parameterize ((current-page page))
    `((html
       (extra-header (@ (name "content-type")
                        (value "text/html; charset=euc-jp")));;for now
       (head (title "Kahua"
                    ,(string-join (pagename-split (ref page 'key))
                                  "|" 'prefix))
	     (meta (@ (http-equiv "Content-type")
		      (content "text/html; charset=euc-jp")))
             (link (@ (rel "stylesheet") (type "text/css")
                      (href ,(kahua-static-document-url
                              "kahua-web/kahua-web.css")))))
       (body
        (div (@ (id "title-pane")) ,@(use-page "/$admin/title-pane"))
        ,@(page-navigation page)
        (hr)
        (table
         (@ (id "body-pane"))
         (tr (td (@ (id "side-pane")) ,@(use-page "/$admin/side-pane"))
             (td (@ (id "main-pane"))
                 ,@(if (front-page? page) '() `((h1 ,(ref page 'title))))
                 ,@(wiliki:format-content page)
                 ,@(if (persistent-page? page) (footer page) '()))
             ))
        (hr)
        (div (@ (id "bottom-pane")) ,@(use-page "/$admin/bottom-pane"))
        )))))

(define (page-navigation page)
  ;; ("/" "a" "b") => (() ("a") ("a" "b"))
  (define (navi-paths pathl)
    (map-with-index (lambda (ind _) (take pathl ind)) (cons #f pathl)))
  ;; "/a/b" => ["Home" ">" "a" ">" "b"] with appropriate links
  (define (navi-links pathl)
    (intersperse " > "
                 (map (lambda (paths name)
                        (if (get-page (pagename-join paths))
                          `(a/cont (@@ (cont ,show ,@paths)) ,name)
                          name))
                      (navi-paths pathl)
                      (cons "Home" pathl))))
  ;; 
  (define (navigation-right)
    `(form/cont 
      (@  (style "margin:0pt; padding:0pt"))
      (@@ (cont ,search))
      ,@(login-link)
	" 検索: "
	(input (@ (style "margin:0pt; padding:0pt")
		  (type "text") (name "word") (size 10)))))
  ;; body
  `((table
     (@ (id "navigation-pane"))
     (tr (td (@ (id "navigation-pane-left"))
             ,@(navi-links (pagename-split (ref page 'key))))
         (td (@ (id "navigation-pane-right"))
	     ,(navigation-right))))))

(define (get-source page-path)
  (or
   (and-let* ((page (get-page page-path))
	      (content (ref page 'content)))
     (if (pair? content)
	 (format "{{{\n~a\n}}}\n" content)
	 (string-concatenate 
	  (map (lambda (line) (format " ~a\n" line))
	       (string-split (ref page 'content) "\n")))))
   (format "* No Such Page: ~a" page-path)))

(define-entry (source :rest page-name)
  (let ((page-path (pagename-join page-name)))
    (standard-page
     (make <page> :title (format "Source of ~a" page-path)
	          :key   (format "/Source/~a" page-path)
                  :content (get-source page-path)))))

(define (redirect-to page)
  (let* ((page (or page (get-page "/"))))
    `((html ;; Needed to make a single SXML node. Will be unnecessary in future.
       (extra-header (@ (name "Status") (value "302 Moved")))
       (extra-header (@ (name "Location")
                        (value ,(kahua-self-uri-full
                                 #`"show,(pagename-join 
                                          (map uri-encode-string
                                               (pagename-split
                                                 (ref page 'key))))"))))))))

(let ((formatter (wiliki:formatter)))
  (set! (ref formatter 'bracket) format-wikiname)
  (set! (ref formatter 'macro) format-macro)
  )

;; A common routine to format a customizable pane
(define (use-page pagename)
  (cond ((get-page pagename) => wiliki:format-content)
        (else (format-wikiname pagename))))

;;========================================================
;; Main application
;;

(define-entry (show :rest page-path)
  (let ((pagename (pagename-join page-path)))
    (cond ((get-page pagename) => standard-page)
          (else (standard-page (make-nonexistent-page pagename))))))

;; assumes pagename is canonicalized
(define (make-nonexistent-page pagename)
  (make-error-page "Error: nonexistent page"
                   `(p "ページ" ,pagename "は存在しません")))

(define (make-error-page title body)
  (make <page> :title title :key "/Error" :content body))

(define (error-proc exc)
  (if (is-a? exc <kahua-error>)
    (ref exc 'form)
    (standard-page
     (make-error-page "Error: program error"
                      `(,@(use-page "/$admin/program-error")
                        (pre ,(kahua-error-string exc (kahua-current-user))))))))

(define-entry (edit :rest page-path)
  (let ((pagename (pagename-join page-path)))
    (cond ((get-page pagename) => edit-page)
          (else (edit-page (make <page> :title pagename :key pagename))))))

(define (edit-page page . extra-contents)
  (define commit
    (entry-lambda (:keyword content donttouch addtonews
                            changename confirmchange)
      (set! (ref page 'content) (canon-content content))
      (and-let* (((equal? confirmchange "on"))
                 (newname (canon-pagename changename)))
        (set! (ref page 'key) newname))
      (save-page page
                 (lambda (page)
                   (unless (equal? donttouch "on")
                     (page-set-push-unique! (page-set:recent-changes) page))
                   (when (equal? addtonews "on")
                     (page-set-push-unique! (page-set:news) page))
                   (redirect-to page)))))
  (if (and-let* ((name (kahua-current-user-name)))
        (not (string-null? name)))
      (let1 epage
        (make <page>
          :title #`"Editing ,(ref page 'title)" :key (ref page 'key)
          :content
          `(,@extra-contents
            (div
             (form/cont
              (@@ (cont ,commit (donttouch) (content)))
              (textarea (@ (name "content") (rows 30) (cols 80))
                        ,(ref page 'content))
              (br)
              (div (@ (class "edit-inputs"))
                   (input (@ (type "submit") (name "commit") (value "Commit")))
                   " "
                   (input (@ (type "checkbox") (name "donttouch") (value "on")
                             (id "donttouch")))
                   (label (@ (for "donttouch")) "Don't update 'Recent Changes'")
                   " "
                   (input (@ (type "checkbox") (name "addtonews") (value "on")
                             (id "addtonews")))
                   (label (@ (for "addtonews")) "Add to news item")
                   (br)
                   "Change Page Name : "
                   (input (@ (type "entry") (name "changename") (width 20)
                             (value ,(ref page 'key))))
                   " "
                   (input (@ (type "checkbox") (name "confirmchange") (value "on")
                             (id "confirmchange")))
                   (label (@ (for "confirmchange")) "I'm sure"))
              (br)
              (div (@ (class "edit-help"))
                   ,@(use-page "/$admin/edit-help"))

              ))))
        (standard-page epage))
      
      (let1 epage
        (make-error-page "Error: Not login"
                         `(p (@ (class "warning"))
                             "To edit a page you have to login!"))
        (standard-page epage))))
        
;; canonicalize EOL to #\newline
(define (canon-content content)
  (string-join (call-with-input-string content port->string-list)
               "\n" 'suffix))

;;========================================================
;; initialization
;;
   
(initialize-main-proc show)

(kahua-error-proc error-proc)
