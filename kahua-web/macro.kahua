;;-*-Scheme-*-
;; Kahua website macro handling
;;
;;  Copyright (c) 2004 Scheme Arts, L.L.C., All rights reserved.
;;  Copyright (c) 2004 Time Intermedia Corporation, All rights reserved.
;;  See COPYING for terms and conditions of using this software
;;
;; $Id: macro.kahua,v 1.25 2006/05/29 10:38:04 bizenn Exp $

(use gauche.collection)
(use sendmail)

(define *macro-alist* '())

(define-syntax define-wiki-macro 
  (syntax-rules ()
    ((_ (name . args) . body)
     (set! *macro-alist*
           (let ((handler (lambda args . body)))
             (acons 'name
                    (lambda (expr)
                      (if (procedure-arity-includes? handler (length expr))
                        (apply handler expr)
                        (unhandled-macro 'name expr)))
                    *macro-alist*))))
    ))

(define (format-macro expr _)
  (define (safe-apply handler)
    (with-error-handler
        (lambda (e)
          `((pre (@ (class "macro-error"))
                 "Error in expanding macro: "
                 (strong ,(write-to-string expr))
                 "\n"
                 ,(kahua-error-string e (kahua-current-user)))))
      (cut handler (cdr expr))))
  (cond ((assq-ref *macro-alist* (car expr)) => safe-apply)
        (else (unhandled-macro (car expr) (cdr expr)))))

(define (unhandled-macro name expr)
  `("##" ,(write-to-string (cons name expr))))

;;=========================================================
;; Macros
;;

;;---------------------------------------------------------
;; A couple of test macros
;;
(define-wiki-macro (test-macro . args) ;; to see if macro is working
  `(,(format "Test macro output ~s" args)))

(define-wiki-macro (test-error . args) ;; to see if macro error is handled
  (error "test-error: " args))

;;---------------------------------------------------------
;; Index, cindex
;;
(define-wiki-macro (index prefix)
  (let1 pages (filter (lambda (data)
                         (string-prefix? (x->string prefix) (ref data 'name)))
                      (all-page-data))
    `((ul ,@(map (lambda (data) `(li ,@(format-wikiname (ref data 'name))))
                 (sort pages pagename<?))))))

(define-wiki-macro (cindex prefix . maybe-delimiter)
  (let ((delim (get-optional maybe-delimiter " "))
        (pages (filter (lambda (data)
                         (string-prefix? (x->string prefix) (ref data 'name)))
                       (all-page-data))))
    (fold-right (lambda (data seed)
                  (if (null? seed)
                    (format-wikiname (ref data 'name))
                    (append (format-wikiname (ref data 'name))
                            (cons delim seed))))
                '()
                (sort pages pagename<?))))

(define-wiki-macro (tree-index prefix)
  (define (render forest)
    `((ul ,@(map (lambda (tree)
                   `(li ,@(format-wikiname (car tree))
                        ,@(if (null? (cddr tree)) '()
                              (render (cddr tree)))))
                 (sort forest (lambda (a b) (string<? (car a) (car b)))))
          )))

  (define (find-parent me forest)
    (find (lambda (x)
            (and (not (eq? me x))
                 (string-prefix? #`",(car x)/" (car me))
                 (not (string-scan (string-drop (car me)
                                                (+ (string-length (car x)) 1))
                                   #\/))))
          forest))
  
  (let1 page-data  ;; ((name root? . children) ...)
      (filter-map (lambda (data)
                    (and (string-prefix? (x->string prefix) (ref data 'name))
                         (list (ref data 'name) #t)))
                  (map identity (all-page-data)))
    (let loop ((pages page-data))
      (cond
       ((null? pages) (render (filter (cut cadr <>) page-data)))
       ((find-parent (car pages) page-data)
        => (lambda (parent)
             (set! (cadr (car pages)) #f)
             (push! (cddr parent) (car pages))
             (loop (cdr pages))))
       (else (loop (cdr pages)))))
    ))
  

;;---------------------------------------------------------
;; Inline image
;;
(define-wiki-macro (img url . attrs)
  `((img (@ (src ,(imgpath (x->string url)))
                 ,@(filter allowed-img-attr? attrs)))))

(define (imgpath path)  ;; remove leading /
  (let1 npath (if (char=? #\/ (string-ref path 0)) (string-drop path 1) path)
    (kahua-static-document-url #`"kahua-web/,npath")))

(define allowed-img-attrs 
  (append '(class id title)
          '(alt longdesc width height)))

(define (allowed-img-attr? attr)
  (memq (car attr) allowed-img-attrs))

;;---------------------------------------------------------
;; generate PDF
(define-wiki-macro (pdf-page)
  (let1 p (current-page)
    `((a/cont (@@ (cont ,(lambda ()
                           `((pdf
                              ,@(parameterize ((current-page p))
                                  (wiliki:format-content
                                   (ref p 'content))))))))
              "PDF"))))

;;---------------------------------------------------------
;; Temporary Contents
;;
(define ***tmp*** (make-parameter '()))
(define-wiki-macro (temporary-contents)
  (***tmp***))

;;---------------------------------------------------------
;; Message to you
;;
;; ##(message-to ("alice" "bob") "Hi. Enjoy hacking?")
;; ##(message-to "alice" "Do you love hacking with Kahua?")

(define-wiki-macro (message-to you msg)
  (or (and-let* ((user (kahua-current-user))
		 (name (ref user 'login-name))
                 (_ (or (and (list? you) (find (cut string=? name <>) you))
			(string=? name you))))
        `((p ,msg)))
      '()))

;;---------------------------------------------------------
;; Include
;;
(define-wiki-macro (include pagename)
  (let1 name (canon-pagename pagename)
    (cond ((and name (get-page name)) => wiliki:format-content)
          (else (unhandled-macro 'include (list pagename))))))

;;---------------------------------------------------------
;; Page-set list
;;
(define-wiki-macro (page-set setname . opts)
  (or (and-let* ((set   (get-page-set (x->string setname)))
                 (num-items (x->integer (get-optional opts 0)))
                 (page-data
                  (filter-map get-page-data-from-id
                              (if (zero? num-items)
                                (ref set 'pages)
                                (take* (ref set 'pages) num-items)))))
        `((ul ,@(map (lambda (data)
                       `(li ,@(format-wikiname (ref data 'name))))
                     page-data))))
      (unhandled-macro 'page-set (cons setname opts))))

;;---------------------------------------------------------
;; Table of contents
;;
(define-wiki-macro (toc . maybe-pagename)
  (let1 page (or (and-let* ((name (get-optional maybe-pagename #f))
                            (cname (canon-pagename (x->string name))))
                   (get-page cname))
                 (wiliki-current-page))
    (if (not page)
      (unhandled-macro 'toc maybe-pagename)
      (let1 pagename (and page (ref page 'key))
        ;; MAKE-UL takes one heading entry (level . text) and tries to fit
        ;; it in a tree.  If the entry is the same level, we accumulate
        ;; the heading entries to ITEMS.  If the entry is deeper than the
        ;; current, we recurse into the deeper level but uses CPS to continue
        ;; the current level after the lower levels are collected.
        ;; NB: hs is a _reverse_ ordered list of all headings (level . text).
        ;; Since it's reversed, we can scan forward to find the heading
        ;; nesting.
        (define (make-ul hs cur items cont)
          (cond ((null? hs)
                 (cont '() `(ul ,@items)))
                ((= (caar hs) cur) ;; same level
                 (make-ul (cdr hs) cur
                          (cons (make-anchor (nestings hs)) items)
                          cont))
                ((> (caar hs) cur) ;; deeper level
                 (make-ul hs (+ cur 1) '()
                          (lambda (hs ul)
                            (make-ul hs cur (cons ul items) cont))))
                (else ;; we finished the current level and under.  pass
                      ;; the result to the continuation proc.
                 (cont hs `(ul ,@items)))))

        (define (nestings hs)
          (reverse!
           (cdr
            (fold (lambda (elt seed)
                    (let ((level (car elt))
                          (cur-level (car seed)))
                      (if (< level cur-level)
                        (list* level (cdr elt) (cdr seed))
                        seed)))
                  '(6)
                  hs))))

        (define (make-anchor headings)
          (let ((id (wiliki:calculate-heading-id headings)))
            `(li (a/cont (@@ (cont ,show
                                   ,@(pagename-split (ref page 'key)))
                             (fragment ,id))
                         ,@(wiliki:format-line-plainly (car headings))))))

        (let1 headings
            (page-lines-fold
             page
             (lambda (l r)
               (cond ((#/^(\*{1,}) / l)
                      => (lambda (m)
                           (acons (string-length (m 1)) (m 'after) r)))
                     (else r)))
             '()
             :follow-includes? #t
             :skip-verbatim? #t)
          (make-ul headings 1 '() (lambda (_ ul) (list ul))))
        ))))

;; Copied from wiliki and modified.
;; The issue here is that this procedure has to recognize include form.
;; It strongly suggest that 'include' shouldn't be a normal macro---rather,
;; it has to be a markup.  I haven't decided how WiLiKi should handle this.
;; So I keep a copy locally for the time being --SK

(define (page-lines-fold page proc seed . keys)
  (let-keywords* keys ((follow-includes? #f)
                       (skip-verbatim? #f))

    (define (content-fold line seed)
      (cond ((eof-object? line) seed)
            ((string=? line "{{{") (verb-fold line seed))
            ((and follow-includes?
                  (#/##(\(include .*)/ line))
             => (lambda (m)
                  (let* ((s (open-input-string (m 1)))
                         (expr (read s)))
                    ;; NB: we ignore the rest of macros.  dont' write
                    ;; two ##(include)'s in one lnie.
                    (if (null? (cdr expr))
                      (content-fold (read-line) seed)
                      (handle-include (x->string (cadr expr)) seed)))))
            (else (content-fold (read-line) (proc line seed)))))

    (define (handle-include pagename seed)
      (let1 page (get-page (canon-pagename pagename))
        (content-fold (read-line)
                      (if page
                        (handle-page page seed)
                        seed))))

    (define (handle-page page seed)
      (if (or (not (is-a? page <wiliki-page>))
              (not (string? (ref page 'content))))
        seed
        (with-input-from-string (ref page 'content)
          (cut with-port-locking (current-input-port)
               (cut content-fold (read-line) seed)))))

    (define (verb-fold line seed)
      (cond ((eof-object? line) seed)
            ((string=? line "}}}")
             (content-fold (read-line)
                           (if skip-verbatim? seed (proc line seed))))
            (else
             (verb-fold (read-line)
                        (if skip-verbatim? seed (proc line seed))))))

    (handle-page page seed)))

;;-----------------------------------------------------------------
;; simple-comment-form
;;
(define-wiki-macro (simple-comment-form comment-name . page-name)
  (or (and-let* ((page (if (null? page-name)
                           (current-page)
                           (get-page (car page-name))))
		 (key (ref page 'persistent-id))
		 (title (ref page 'title))
	         (key (string-append title "(" key ")" "-" (x->string comment-name))))
        (define commit-comment
	  (entry-lambda (:keyword author contents)
            ;; commit
            (if (not (or (string-null? (string-trim author)) 
			 (string-null? (string-trim contents))))
		(let* ((set (or (find-kahua-instance <simple-comment-set> key)
				(make <simple-comment-set> :name key)))
		       (comment (make <simple-comment>
				  :author (string-trim-both author)
				  :contents (string-trim-both contents))))
		  (set! (ref set 'comments) 
			(cons comment (ref set 'comments)))))
	    ;; redirect to this page
	    (redirect-to page)))
	(define (comment-list)
	  (let* ((comments (find-kahua-instance <simple-comment-set> key)))
	    (if comments
		`(div 
		  ,@(filter-map (lambda (c)
				  (and c
				       (if (visible? c)
					   `(div (@ (class "comment"))
						 (div (@ (class "comment-header"))
						      ,(ref c 'author)
						      ": (" ,(sys-ctime (ref c 'date)) ")")
						 (div (@ (class "comment-contents"))
						      ,@(wiliki:format-content
							 (string-append
							  "{{{\n"
							  (or (ref c 'contents) "")
							  "\n}}}"))))
					   '())))
				(reverse (ref comments 'comments))))
		"There is no comment.")))
	;; form
	`(div (@ (class "simplecommentmacro"))
	      (div (@ (class "commentform"))
		   (form/cont 
		    (@@ (cont ,commit-comment))
		    (div "Name: "
			 (input (@ (type "text") 
				   (name "author") (size "20") (maxlength "20"))))
		    (div "Comment: "
			 (textarea (@ (name "contents") 
				      (cols "70") (rows "3"))))
		    (div (input (@ (type "submit") (name "submit")
				   (value "submit"))))))
	      (div (@ (class "comments"))
		   ,(comment-list))))
      '()))

;;-----
;(define *kahua-web-admin* "oss@oss.timedia.co.jp")

(define-wiki-macro (simple-comment-form-bis comment-name . rest)
  (let-keywords* rest ((page-name #f)
                       (mail-to #f)
                       (mail-from #f))
    (or (and-let* ((page (if (not page-name)
                             (current-page)
                             (get-page page-name)))
                   (key (ref page 'persistent-id))
                   (title (ref page 'title))
                   (key (string-append title "(" key ")" "-"
                                       (x->string comment-name))))
        (define commit-comment
	  (entry-lambda (:keyword author contents)
            ;; commit
            (if (not (or (string-null? (string-trim author)) 
			 (string-null? (string-trim contents))))
		(let* ((set (or (find-kahua-instance <simple-comment-set> key)
				(make <simple-comment-set> :name key)))
		       (comment (make <simple-comment>
				  :author (string-trim-both author)
				  :contents (string-trim-both contents))))
		  (set! (ref set 'comments) 
			(cons comment (ref set 'comments)))
                  (if mail-to
                      (notice-mail mail-to mail-from comment))
                  ))
	    ;; redirect to this page
	    (redirect-to page)))
        (define (notice-mail mail-to mail-from comment)
          (let* ((author (ref comment 'author))
                 (contents (ref comment 'contents))
                 (page-path (ref page 'key))
                 (subject (string-append author " comments on " page-path)))
            (sendmail mail-to
                      (or mail-from *kahua-web-email*) subject contents)))
	(define (comment-list)
	  (let* ((comments (find-kahua-instance <simple-comment-set> key)))
	    (if comments
		`(div 
		  ,@(map (lambda (c)
			   (if (visible? c)
			       `(div (@ (class "comment"))
				     (div (@ (class "comment-header"))
					  ,(ref c 'author)
					  ": (" ,(sys-ctime (ref c 'date)) ")")
				     (div (@ (class "comment-contents"))
					  ,@(wiliki:format-content
                                             (string-append
                                              "{{{\n"
                                              (or (ref c 'contents) "")
                                              "\n}}}"))))
			       '()))
			 (reverse (ref comments 'comments))))
		"There is no comment.")))
	;; form
	`(div (@ (class "simplecommentmacro"))
	      (div (@ (class "commentform"))
		   (form/cont 
		    (@@ (cont ,commit-comment))
		    (div "Name: "
			 (input (@ (type "text") 
				   (name "author") (size "20") (maxlength "20"))))
		    (div "Comment: "
			 (textarea (@ (name "contents") 
				      (cols "70") (rows "3"))))
		    (div (input (@ (type "submit") (name "submit")
				   (value "submit"))))))
	      (div (@ (class "comments"))
		   ,(comment-list))))
      '()))
  )
